import type { CameraSettings } from "../Camera+Related";
import { CameraPosition } from "../Camera+Related";
import type { DeviceCamera } from "../private/CameraAccess";
import type { ReportCameraPropertiesParameters } from "../worker/dataCaptureEngine";
export declare enum MeteringMode {
    CONTINUOUS = "continuous",
    MANUAL = "manual",
    NONE = "none",
    SINGLE_SHOT = "single-shot"
}
export declare enum CameraResolutionConstraint {
    ULTRA_HD = 0,
    FULL_HD = 1,
    HD = 2,
    SD = 3,
    NONE = 4
}
export interface ExtendedMediaTrackCapabilities extends MediaTrackCapabilities {
    exposureCompensation?: DoubleRange;
    exposureMode?: MeteringMode[];
    exposureTime?: DoubleRange;
    focusDistance?: DoubleRange;
    focusMode?: MeteringMode[];
    torch?: boolean;
    zoom?: DoubleRange;
}
export interface ExtendedMediaTrackConstraintSet extends MediaTrackConstraintSet {
    exposureCompensation?: ConstrainDouble | number;
    exposureMode?: MeteringMode;
    exposureTime?: ConstrainDouble | number;
    focusDistance?: ConstrainDouble | number;
    focusMode?: MeteringMode;
    torch?: boolean;
    zoom?: ConstrainDouble | number;
}
export interface GUI {
    isCameraRecoveryVisible: () => boolean;
    setCameraRecoveryVisible: (visible: boolean) => void;
}
export interface FrameCapture {
    data: Uint8ClampedArray;
    height: number;
    width: number;
}
export declare enum CameraManagerEvent {
    CAMERA_PROPERTIES = "cameraProperties",
    CAMERA_ACCESS_ERROR = "cameraAccessError"
}
export declare type CameraManagerEventParameters<C> = C extends CameraManagerEvent.CAMERA_PROPERTIES ? ReportCameraPropertiesParameters : C extends CameraManagerEvent.CAMERA_ACCESS_ERROR ? any : never;
/**
 * A barcode picker utility class used to handle camera interaction.
 */
export declare class CameraManager {
    private static readonly autofocusIntervalMs;
    private static readonly cameraAccessTimeoutMs;
    private static readonly getCapabilitiesTimeoutMs;
    private static readonly manualFocusWaitTimeoutMs;
    private static readonly manualToAutofocusResumeTimeoutMs;
    private static readonly noCameraErrorParameters;
    private static readonly notReadableErrorParameters;
    private static readonly videoMetadataCheckIntervalMs;
    private static readonly videoMetadataCheckTimeoutMs;
    private static MIRRORED_CLASS_NAME;
    private static _instance;
    activeCamera?: DeviceCamera;
    activeCameraSettings?: CameraSettings;
    canvas: HTMLCanvasElement;
    gui: GUI;
    selectedCamera?: DeviceCamera;
    videoElement: HTMLVideoElement;
    private readonly checkCameraVideoStreamAccessIfVisibleListener;
    private readonly handleWebGLContextLostListener;
    private readonly listeners;
    private readonly mirrorImageOverrides;
    private readonly postStreamInitializationListener;
    private readonly triggerFatalError;
    private readonly triggerManualFocusListener;
    private readonly triggerZoomMoveListener;
    private readonly triggerZoomStartListener;
    private readonly videoResizeListener;
    private readonly videoTrackEndedListener;
    private readonly videoTrackMuteListener;
    private _canvas2dContext;
    private _canvasWebGLContext;
    private _imageData?;
    private _mediaStream?;
    private abortedCameraInitializationResolveCallback?;
    private autofocusInterval;
    private cameraAccessRejectCallback?;
    private cameraAccessTimeout;
    private cameraInitializationPromise?;
    private cameraPosition;
    private cameraSetupPromise?;
    private getCapabilitiesTimeout;
    private manualFocusWaitTimeout;
    private manualToAutofocusResumeTimeout;
    private mediaTrackCapabilities?;
    private mediaTrackCapabilitiesPromise?;
    private mediaTrackCapabilitiesPromiseResolver?;
    private pinchToZoomDistance?;
    private pinchToZoomEnabled;
    private pinchToZoomInitialZoom;
    private selectedCameraSettings?;
    private tapToFocusEnabled;
    private torchEnabled;
    private torchToggleEnabled;
    private videoMetadataCheckInterval;
    private isWebGLSupported;
    constructor();
    set imageData(imageData: Uint8ClampedArray);
    get mediaStream(): MediaStream | undefined;
    set mediaStream(stream: MediaStream | undefined);
    private get canvas2dContext();
    private get canvasWebGLContext();
    static instance(): CameraManager;
    requestVideoFrame(scheduledFunction: FrameRequestCallback | VideoFrameRequestCallback): number;
    cancelVideoFrame(id: number): void;
    addListener<E extends CameraManagerEvent>(event: CameraManagerEvent, listener: (details: CameraManagerEventParameters<E>) => void): void;
    applyCameraSettings(cameraSettings?: CameraSettings): Promise<void>;
    captureImage(): FrameCapture | null;
    initializeCameraWithSettings(camera?: DeviceCamera, cameraSettings?: CameraSettings): Promise<void>;
    isMirrorImageEnabled(): boolean;
    isPinchToZoomEnabled(): boolean;
    isTapToFocusEnabled(): boolean;
    isTorchAvailable(): Promise<boolean>;
    playVideo(): Promise<void>;
    reinitializeCamera(): Promise<void>;
    removeListener<E extends CameraManagerEvent>(event: CameraManagerEvent, listenerToRemove?: (details: CameraManagerEventParameters<E>) => void): void;
    setCameraPosition(cameraPosition: CameraPosition): Promise<void>;
    setExposure(exposure: {
        compensation?: number;
        time?: number;
    }): Promise<void>;
    setFocus(manualLensPosition: number): Promise<void>;
    setFrameRate(frameRate: {
        min?: number;
        max?: number;
    }): Promise<void>;
    setInitialCameraPosition(cameraPosition: CameraPosition): void;
    setInteractionOptions(torchToggleEnabled: boolean, tapToFocusEnabled: boolean, pinchToZoomEnabled: boolean): void;
    setMirrorImageEnabled(enabled: boolean, override: boolean): void;
    setPinchToZoomEnabled(enabled: boolean): void;
    setSelectedCamera(camera?: DeviceCamera): void;
    setSelectedCameraSettings(cameraSettings?: CameraSettings): void;
    setTapToFocusEnabled(enabled: boolean): void;
    setTorchEnabled(enabled: boolean): Promise<void>;
    setZoom(zoomFactor: number): Promise<void>;
    setupCameras(): Promise<void>;
    pauseStream(): void;
    resumeStream(): void;
    stopStream(cameraInitializationFailure?: boolean): Promise<void>;
    toggleTorch(): Promise<void>;
    updateCanvasVideoImage(): void;
    waitForCapabilities(): Promise<void>;
    private accessAutoselectedCamera;
    private accessInitialCamera;
    /**
     * When a context has been created for a canvas, it is not possible to get another one from another type.
     * This function re-creates a new canvas based on the existing one.
     */
    private recreateCanvas;
    private captureImageFor2dContext;
    private captureImageForWebGLContext;
    private checkCameraAccess;
    private checkCameraVideoStreamAccessIfVisible;
    private checkVideoMetadata;
    private disablePinchToZoomListeners;
    private disableTapToFocusListeners;
    private emit;
    private enablePinchToZoomListeners;
    private enableTapToFocusListeners;
    private getActiveCamera;
    private getInitialCameraResolutionConstraint;
    private handleCameraInitializationError;
    private handleVideoResize;
    private handleWebGLContextLost;
    private initializeCameraAndCheckUpdatedSettings;
    private initializeCameraForResolution;
    private initializeStreamForResolution;
    private isVideoAndContextStateValid;
    private postStreamInitialization;
    private recoverStreamIfNeeded;
    private reportCameraProperties;
    private setCameraAccessTimeout;
    private setupAutofocus;
    private setupCameraStreamVideo;
    private setupCamerasAndStream;
    private storeStreamCapabilities;
    private triggerAutoFocus;
    private triggerFocusMode;
    private triggerManualFocus;
    private triggerManualFocusForContinuous;
    private triggerManualFocusForSingleShot;
    private triggerZoomMove;
    private triggerZoomStart;
    private updateActiveCameraCurrentResolution;
    private updateStreamForResolution;
    private videoTrackEndedRecovery;
    private videoTrackMuteRecovery;
}
