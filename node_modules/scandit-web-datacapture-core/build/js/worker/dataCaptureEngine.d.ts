/// <reference types="offscreencanvas" />
import type { DataCaptureContextJSON, PointJSON, PrivateLoadableFrameData } from "..";
import type { EngineWorkerResponse, ModuleHandler } from "./dataCapture.worker";
import type { OverrideState } from "./dataCaptureLoader";
import type { DataCaptureCallbackMessage, DataCaptureContext, DataCaptureContextDeserializer, DataCaptureImageBufferFrameSource, DataCaptureView, Module, Vector, WasmFrameData, PerformanceMetrics, GestureRecognizer } from "./dataCaptureWorker+related";
import { PrivateMirrorAxis } from "../DataCaptureContext+Related";
import type { ProgressInfo } from "../LoadingStatus";
import type { Commands } from "../typings/vgCommandContext";
export interface LoadLibraryParameters {
    libraryLocation: string;
    locationPath: string;
    preloadEngine: boolean;
    writableDataPathOverride?: string;
    overrideSimdSupport: OverrideState;
    overrideThreadsSupport: OverrideState;
    onProgress?: (info: ProgressInfo) => void;
}
export interface CreateContextParameters {
    context: DataCaptureContextJSON;
    deviceId: string;
    domain: string;
    delayedRegistration: boolean;
    highEndBlurryRecognition: boolean;
}
export interface UpdateContextParameters {
    context: DataCaptureContextJSON;
    view: {
        width: number;
        height: number;
    } | null;
}
export interface SetFrameSourceParameters {
    mirrorAxis: PrivateMirrorAxis;
}
export interface ProcessFrameParameters {
    data: Uint8ClampedArray;
    height: number;
    width: number;
}
export interface ReportCameraPropertiesParameters {
    deviceId: string;
    hasAutofocus: boolean;
    isFrontFacing: boolean;
}
export interface WorkerFunctions {
    getOffscreenCanvas: () => OffscreenCanvas | undefined;
    postMessage: (message: DataCaptureCallbackMessage, transfer?: Transferable[]) => void;
}
/**
 * DataCaptureEngine is an abstraction of the engine, it is created by the engine worker
 * and should be used as a singleton. It calls the underlying engine methods directly.
 */
export declare class DataCaptureEngine<M extends Module> {
    context: DataCaptureContext;
    lastUsedModuleMirrorAxis: unknown;
    view: DataCaptureView | undefined;
    protected readonly MAX_NUMBER_OF_IMAGES_IN_FRAME_DATA_POOL: number;
    protected readonly moduleHandler: ModuleHandler<M>;
    protected readonly redrawInterval: number;
    protected readonly redrawRequests: number[];
    protected readonly workerFunctions: WorkerFunctions;
    protected _isDrawLoopRunning: boolean;
    protected contextDeserializer: DataCaptureContextDeserializer | undefined;
    protected frameDataPool: Map<number, Uint8ClampedArray>;
    protected imageFrameSource?: DataCaptureImageBufferFrameSource;
    protected lastFrameCounter: number;
    protected libraryLoadingPromise: Promise<void> | undefined;
    protected loopTimeoutId?: ReturnType<typeof setTimeout>;
    protected resourcePath: string;
    protected writableDataPath: string;
    protected poorMansBenchmarkLogs: boolean;
    protected readonly writableDataPathPreload: string;
    protected readonly writableDataPathStandard: string;
    protected readonly resourceFilesSubfolder: string;
    protected performanceMetricsReporterTimer: ReturnType<typeof setTimeout> | undefined;
    protected performanceMetrics: PerformanceMetrics;
    protected gestureRecognizer: GestureRecognizer | null;
    private gestureListener;
    constructor(moduleHandler: ModuleHandler<M>, workerFunctions: WorkerFunctions);
    get Module(): M;
    set isDrawLoopRunning(newValue: boolean);
    get isDrawLoopRunning(): boolean;
    setPoorMansBenchmarkLogs(enable: boolean): void;
    convertToLoadableFrameData(frameData: WasmFrameData): PrivateLoadableFrameData;
    createContext(createContextJSON: CreateContextParameters): EngineWorkerResponse<"createContext">;
    onTap(point: PointJSON): void;
    startReportingPerformanceMetrics(): void;
    reportPerformanceMetrics(): Promise<void>;
    deleteFrameData(frameId: number): void;
    dispose(): EngineWorkerResponse<"dispose">;
    extractCentaurusLicense(scanditLicenseKey: string): EngineWorkerResponse<"extractCentaurusLicense">;
    getModeDeserializers(): Vector;
    loadLibrary(parameters: LoadLibraryParameters): EngineWorkerResponse<"loadLibrary">;
    processFrame(parameters: ProcessFrameParameters): EngineWorkerResponse<"processFrame">;
    reportCameraProperties(properties: ReportCameraPropertiesParameters): EngineWorkerResponse<"reportCameraProperties">;
    requestFrameData(frameId: number): EngineWorkerResponse<"requestFrameData">;
    scheduleRedraw(view: DataCaptureView, redrawInMs: number): void;
    sendViewRefreshCommands(commands: Commands[]): void;
    setFrameSource(mirrorAxis: PrivateMirrorAxis): EngineWorkerResponse<"setFrameSource">;
    /**
     * The draw loop check at regular interval if any redraw request were made by the engine.
     * If a redraw is necessary, it gathers and sends drawing commands to the main thread.
     */
    startDrawLoop(view: DataCaptureView): void;
    updateContext(contextUpdateParameters: UpdateContextParameters): EngineWorkerResponse<"updateContext">;
    protected getNextFrameId(): number;
    protected getWasmDynamicLibraries(coreWasmURI: string): string[];
    protected getWasmCoreExpectedHash(simdSupport: boolean, threadsSupport: boolean): string;
    protected getWasmCoreFileName(simdSupport: boolean, threadsSupport: boolean): string;
    protected getWasmMetadata(): Record<string, {
        bytes: number;
    }>;
    protected getWasmSideModuleFileName(): string;
    private _loadProgressCallback;
    /**
     * Redraw requests are scheduled at [now + redrawInMs], so when pushed they must be sorted
     * in chronological order so that we can later easily check if we need to redraw by checking
     * the first element.
     * @param redrawInMs
     */
    private addRedrawRequest;
    private contextDidChangeStatus;
    private didStartObservingContext;
    private mapMirrorAxisOnModule;
    private setView;
    private setViewRefreshHandler;
    private setupDataDecoding;
    private start;
    private getWritableDataPath;
    private setup;
}
