import type { CameraSettingsJSON, FrameSource, FrameSourceJSON, FrameSourceListener } from "./Camera+Related";
import { CameraPosition, CameraSettings, FrameSourceState, TorchState } from "./Camera+Related";
import type { DeviceCamera } from "./CameraAccess";
import { CameraManager } from "./private/CameraManager";
import type { Serializable } from "./private/Serializable";
export interface CameraJSON extends FrameSourceJSON {
    type: "camera";
    position: CameraPosition;
    settings: CameraSettingsJSON | Record<string, never>;
    desiredState: FrameSourceState;
    desiredTorchState: TorchState;
}
export interface VideoFrameResolution {
    readonly width: number;
    readonly height: number;
}
export declare class Camera implements FrameSource, Serializable<CameraJSON> {
    readonly label: string;
    deviceId: string;
    readonly position: CameraPosition;
    private _currentResolution?;
    private readonly cameraManager;
    private readonly type;
    private readonly webGLContextLostListener;
    private _currentState;
    private settings;
    private _desiredTorchState;
    private _desiredState;
    private readonly listeners;
    private _context;
    private _desiredMirrorImageEnabled?;
    private _lastCaptureRequestAnimationFrame?;
    private _lastCanvasVideoPreviewAnimationFrame?;
    private _isAndroidWebView?;
    private readonly stateTransitionStrategyMap;
    constructor(manager?: CameraManager);
    static get default(): Camera;
    get desiredState(): FrameSourceState;
    get currentResolution(): VideoFrameResolution | null;
    private get context();
    private set context(value);
    private get currentState();
    static atPosition(cameraPosition: CameraPosition): Camera | null;
    static fromDeviceCamera(deviceCamera: DeviceCamera): Camera;
    switchToDesiredState(state: FrameSourceState): Promise<void>;
    getDesiredTorchState(): TorchState;
    setDesiredTorchState(desiredTorchState: TorchState): Promise<void>;
    isTorchAvailable(): Promise<boolean>;
    addListener(listener: FrameSourceListener | null): void;
    removeListener(listener: FrameSourceListener | null): void;
    applySettings(settings: CameraSettings): Promise<void>;
    toJSONObject(): CameraJSON;
    getMirrorImageEnabled(): boolean;
    setMirrorImageEnabled(enabled: boolean): Promise<void>;
    getCurrentState(): FrameSourceState;
    private setCurrentState;
    /**
     * Starts camera according to the given position. If a deviceId is set, pre-select the corresponding camera.
     * The function returns as soon as the camera has started successfully and is active. The label and
     * position properties reflect then the values found in the accessed stream.
     */
    private setupCamera;
    private notifyContext;
    private notifyListeners;
    private updateCanvasVideoImage;
    private captureAndSend;
    /**
     * Capture images from the video stream and send them to the context. If no context is set, the function will
     * stop itself until called again. While no enabled mode is present in the context, the function will schedule itself
     * again indefinitely without doing anything else.
     */
    private startSendingCapturesToWorker;
    private transitionFromStateOffToOn;
    private transitionFromStateOffToStandby;
    private transitionFromStateOnToOff;
    private transitionFromStateOnToStandby;
    private transitionFromStateStandbyToOff;
    private transitionFromStateStandbyToOn;
    private isAndroidWebView;
}
